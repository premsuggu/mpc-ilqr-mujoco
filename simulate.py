#!/usr/bin/env python3
"""
MPC Results Visualization Script

This script loads the q_optimal.csv generated by the MPC and visualizes 
the robot executing the optimal trajectory in MuJoCo viewer.

Usage:
    python simulate.py

Make sure to run the MPC first to generate q_optimal.csv in the results folder.
"""

import numpy as np
import pandas as pd
import mujoco
import mujoco.viewer
import time
import os
import yaml

def load_config(config_path="config.yaml"):
    """Load configuration from YAML file"""
    with open(config_path, 'r') as f:
        return yaml.safe_load(f)

def main():
    # Load configuration
    try:
        config = load_config()
        model_path = config['robot']['model_path']
        results_dir = config['paths']['results_dir']
        q_optimal_path = os.path.join(results_dir, "q_optimal.csv")
    except FileNotFoundError:
        print("Warning: config.yaml not found, using default paths")
        model_path = "robots/h1_description/mjcf/scene.xml"
        q_optimal_path = "results/q_optimal.csv"
    except KeyError as e:
        print(f"Warning: Missing key in config.yaml: {e}, using default paths")
        model_path = "robots/h1_description/mjcf/scene.xml"
        q_optimal_path = "results/q_optimal.csv"
    
    # Check if files exist
    if not os.path.exists(model_path):
        print(f"Error: Model file not found at {model_path}")
        print("Make sure you're running this script from the project root directory.")
        return
    
    if not os.path.exists(q_optimal_path):
        print(f"Error: q_optimal.csv not found at {q_optimal_path}")
        print("Please run the MPC simulation first to generate the trajectory file.")
        return
    
    # Load MuJoCo model
    print("Loading MuJoCo model...")
    model = mujoco.MjModel.from_xml_path(model_path)
    data = mujoco.MjData(model)
    
    model.opt.gravity = np.array([0, 0, 0])
    
    print(f"Model loaded: nq={model.nq}, nv={model.nv}, nu={model.nu}")
    
    # Load optimal trajectory from MPC
    q_df = pd.read_csv(q_optimal_path)
    
    # Extract only the q columns (skip step and time_sec columns)
    q_columns = [col for col in q_df.columns if col.startswith('q_')]
    q_trajectory = q_df[q_columns].values
    
    print(f"Model's nq: {model.nq} | Trajectory's nq: {q_trajectory.shape[1]}")
    
    # Verify dimensions
    if q_trajectory.shape[1] != model.nq:
        print(f"Warning: Trajectory dimension mismatch!")
        print(f"Model nq: {model.nq}, Trajectory columns: {q_trajectory.shape[1]}")
        return
    
    # Add some standing poses at the beginning for better visualization
    print("Adding standing poses at beginning...")
    standing_pose = np.zeros((5, model.nq))
    standing_pose[:, 2] = 1.0432         # Z (base/pelvis height) for h1
    standing_pose[:, 3] = 1.0            # quaternion w
    
    # Combine standing + MPC trajectory
    full_trajectory = np.vstack((standing_pose, q_trajectory))
    
    print(f"Standing pose (x, y, z): {standing_pose[0, :3]}")
    print(f"Standing pose quaternion: {standing_pose[0, 3:7]}")
    
    # Simulation parameters
    frame = 0
    num_frames = len(full_trajectory)
    fps = 50  # Match MPC frequency (50Hz = 0.02s timestep)
    
    print(f"\nStarting Simulation at {fps} FPS for {len(full_trajectory)} steps")
    
    with mujoco.viewer.launch_passive(model, data) as viewer:
        while viewer.is_running():
            # Set robot configuration to current frame
            data.qpos[:] = full_trajectory[frame]
            
            # Forward kinematics to update visualization
            mujoco.mj_forward(model, data)
            
            # Sync with viewer
            viewer.sync()
            
            # Advance frame
            frame = (frame + 1) % num_frames
            
            # Control frame rate
            time.sleep(1.0 / fps)
    
if __name__ == "__main__":
    main()